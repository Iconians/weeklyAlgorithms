// Implement a Queue Using Stacks:
// Implement a queue using two stacks. The operations should have an average time complexity of O(1) for enqueue and dequeue.
// Hint: One stack is used for enqueueing, and the other for dequeuing.

// Circular Queue:
// Implement a circular queue with fixed size. It should support the following operations: enqueue, dequeue, peek, and isEmpty.
// Hint: Use an array and wrap around when the end of the queue is reached.

// Sliding Window Maximum:
// Given an array of integers and a sliding window size k, find the maximum element in each window.
// Hint: Use a deque (a queue) to keep track of the indices of the elements in the current window.

// Queue Reversal:
// Implement a function to reverse the elements of a queue without using any additional data structures.
// Hint: Use recursion to dequeue and enqueue elements back in reverse order.

// Level Order Traversal of a Binary Tree:
// Implement level-order traversal (breadth-first traversal) of a binary tree. The result should be a list of lists, where each inner list contains the nodes at the same level.
// Hint: Use a queue to explore each level of the tree.

// combined problems with stacks and queues

// Generate Binary Numbers from 1 to N:
// Write a function that generates binary numbers from 1 to N.
// Hint: Use a queue to generate numbers level by level, appending '0' and '1' to each binary number.

// Implement an Online Order System:
// Create a system to manage customers who arrive and leave a service area (queue). Implement functionality to process orders in the order they arrive, and support adding or removing customers dynamically.
// Hint: Use a queue to handle the order processing and allow new customers to enter or leave based on priority.
